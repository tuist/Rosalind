// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Source: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/main/tools/aapt2/Resources.proto
// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Aapt_Pb_StringPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_SourcePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lineNumber: UInt32 = 0

  var columnNumber: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pathIdx: UInt32 = 0

  var position: Aapt_Pb_SourcePosition {
    get {return _position ?? Aapt_Pb_SourcePosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Aapt_Pb_SourcePosition? = nil
}

struct Aapt_Pb_ToolFingerprint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tool: String = String()

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_DynamicRefTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packageID: Aapt_Pb_PackageId {
    get {return _packageID ?? Aapt_Pb_PackageId()}
    set {_packageID = newValue}
  }
  /// Returns true if `packageID` has been explicitly set.
  var hasPackageID: Bool {return self._packageID != nil}
  /// Clears the value of `packageID`. Subsequent reads from it will return its default value.
  mutating func clearPackageID() {self._packageID = nil}

  var packageName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packageID: Aapt_Pb_PackageId? = nil
}

struct Aapt_Pb_ResourceTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourcePool: Aapt_Pb_StringPool {
    get {return _sourcePool ?? Aapt_Pb_StringPool()}
    set {_sourcePool = newValue}
  }
  /// Returns true if `sourcePool` has been explicitly set.
  var hasSourcePool: Bool {return self._sourcePool != nil}
  /// Clears the value of `sourcePool`. Subsequent reads from it will return its default value.
  mutating func clearSourcePool() {self._sourcePool = nil}

  var package: [Aapt_Pb_Package] = []

  var overlayable: [Aapt_Pb_Overlayable] = []

  var toolFingerprint: [Aapt_Pb_ToolFingerprint] = []

  var dynamicRefTable: [Aapt_Pb_DynamicRefTable] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sourcePool: Aapt_Pb_StringPool? = nil
}

struct Aapt_Pb_PackageId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_Package {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packageID: Aapt_Pb_PackageId {
    get {return _packageID ?? Aapt_Pb_PackageId()}
    set {_packageID = newValue}
  }
  /// Returns true if `packageID` has been explicitly set.
  var hasPackageID: Bool {return self._packageID != nil}
  /// Clears the value of `packageID`. Subsequent reads from it will return its default value.
  mutating func clearPackageID() {self._packageID = nil}

  var packageName: String = String()

  var type: [Aapt_Pb_Type] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packageID: Aapt_Pb_PackageId? = nil
}

struct Aapt_Pb_TypeId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_Type {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var typeID: Aapt_Pb_TypeId {
    get {return _typeID ?? Aapt_Pb_TypeId()}
    set {_typeID = newValue}
  }
  /// Returns true if `typeID` has been explicitly set.
  var hasTypeID: Bool {return self._typeID != nil}
  /// Clears the value of `typeID`. Subsequent reads from it will return its default value.
  mutating func clearTypeID() {self._typeID = nil}

  var name: String = String()

  var entry: [Aapt_Pb_Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _typeID: Aapt_Pb_TypeId? = nil
}

struct Aapt_Pb_Visibility {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: Aapt_Pb_Visibility.Level = .unknown

  var source: Aapt_Pb_Source {
    get {return _source ?? Aapt_Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var comment: String = String()

  var stagedApi: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Level: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case `private` // = 1
    case `public` // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .private
      case 2: self = .public
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .private: return 1
      case .public: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _source: Aapt_Pb_Source? = nil
}

#if swift(>=4.2)

extension Aapt_Pb_Visibility.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_Visibility.Level] = [
    .unknown,
    .private,
    .public,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_AllowNew {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Aapt_Pb_Source {
    get {return _source ?? Aapt_Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Aapt_Pb_Source? = nil
}

struct Aapt_Pb_Overlayable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var source: Aapt_Pb_Source {
    get {return _source ?? Aapt_Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var actor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Aapt_Pb_Source? = nil
}

struct Aapt_Pb_OverlayableItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Aapt_Pb_Source {
    get {return _source ?? Aapt_Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var comment: String = String()

  var policy: [Aapt_Pb_OverlayableItem.Policy] = []

  var overlayableIdx: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Policy: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case `public` // = 1
    case system // = 2
    case vendor // = 3
    case product // = 4
    case signature // = 5
    case odm // = 6
    case oem // = 7
    case actor // = 8
    case configSignature // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .public
      case 2: self = .system
      case 3: self = .vendor
      case 4: self = .product
      case 5: self = .signature
      case 6: self = .odm
      case 7: self = .oem
      case 8: self = .actor
      case 9: self = .configSignature
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .public: return 1
      case .system: return 2
      case .vendor: return 3
      case .product: return 4
      case .signature: return 5
      case .odm: return 6
      case .oem: return 7
      case .actor: return 8
      case .configSignature: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _source: Aapt_Pb_Source? = nil
}

#if swift(>=4.2)

extension Aapt_Pb_OverlayableItem.Policy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_OverlayableItem.Policy] = [
    .none,
    .public,
    .system,
    .vendor,
    .product,
    .signature,
    .odm,
    .oem,
    .actor,
    .configSignature,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_StagedId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Aapt_Pb_Source {
    get {return _source ?? Aapt_Pb_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var stagedID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Aapt_Pb_Source? = nil
}

struct Aapt_Pb_EntryId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_Entry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryID: Aapt_Pb_EntryId {
    get {return _storage._entryID ?? Aapt_Pb_EntryId()}
    set {_uniqueStorage()._entryID = newValue}
  }
  /// Returns true if `entryID` has been explicitly set.
  var hasEntryID: Bool {return _storage._entryID != nil}
  /// Clears the value of `entryID`. Subsequent reads from it will return its default value.
  mutating func clearEntryID() {_uniqueStorage()._entryID = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var visibility: Aapt_Pb_Visibility {
    get {return _storage._visibility ?? Aapt_Pb_Visibility()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  var allowNew: Aapt_Pb_AllowNew {
    get {return _storage._allowNew ?? Aapt_Pb_AllowNew()}
    set {_uniqueStorage()._allowNew = newValue}
  }
  /// Returns true if `allowNew` has been explicitly set.
  var hasAllowNew: Bool {return _storage._allowNew != nil}
  /// Clears the value of `allowNew`. Subsequent reads from it will return its default value.
  mutating func clearAllowNew() {_uniqueStorage()._allowNew = nil}

  var overlayableItem: Aapt_Pb_OverlayableItem {
    get {return _storage._overlayableItem ?? Aapt_Pb_OverlayableItem()}
    set {_uniqueStorage()._overlayableItem = newValue}
  }
  /// Returns true if `overlayableItem` has been explicitly set.
  var hasOverlayableItem: Bool {return _storage._overlayableItem != nil}
  /// Clears the value of `overlayableItem`. Subsequent reads from it will return its default value.
  mutating func clearOverlayableItem() {_uniqueStorage()._overlayableItem = nil}

  var configValue: [Aapt_Pb_ConfigValue] {
    get {return _storage._configValue}
    set {_uniqueStorage()._configValue = newValue}
  }

  var stagedID: Aapt_Pb_StagedId {
    get {return _storage._stagedID ?? Aapt_Pb_StagedId()}
    set {_uniqueStorage()._stagedID = newValue}
  }
  /// Returns true if `stagedID` has been explicitly set.
  var hasStagedID: Bool {return _storage._stagedID != nil}
  /// Clears the value of `stagedID`. Subsequent reads from it will return its default value.
  mutating func clearStagedID() {_uniqueStorage()._stagedID = nil}

  var flagDisabledConfigValue: [Aapt_Pb_ConfigValue] {
    get {return _storage._flagDisabledConfigValue}
    set {_uniqueStorage()._flagDisabledConfigValue = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Aapt_Pb_ConfigValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: Aapt_Pb_Configuration {
    get {return _config ?? Aapt_Pb_Configuration()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var value: Aapt_Pb_Value {
    get {return _value ?? Aapt_Pb_Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Aapt_Pb_Configuration? = nil
  fileprivate var _value: Aapt_Pb_Value? = nil
}

struct Aapt_Pb_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Aapt_Pb_Source {
    get {return _storage._source ?? Aapt_Pb_Source()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  var comment: String {
    get {return _storage._comment}
    set {_uniqueStorage()._comment = newValue}
  }

  var weak: Bool {
    get {return _storage._weak}
    set {_uniqueStorage()._weak = newValue}
  }

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var item: Aapt_Pb_Item {
    get {
      if case .item(let v)? = _storage._value {return v}
      return Aapt_Pb_Item()
    }
    set {_uniqueStorage()._value = .item(newValue)}
  }

  var compoundValue: Aapt_Pb_CompoundValue {
    get {
      if case .compoundValue(let v)? = _storage._value {return v}
      return Aapt_Pb_CompoundValue()
    }
    set {_uniqueStorage()._value = .compoundValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case item(Aapt_Pb_Item)
    case compoundValue(Aapt_Pb_CompoundValue)

  #if !swift(>=4.1)
    static func ==(lhs: Aapt_Pb_Value.OneOf_Value, rhs: Aapt_Pb_Value.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.item, .item): return {
        guard case .item(let l) = lhs, case .item(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compoundValue, .compoundValue): return {
        guard case .compoundValue(let l) = lhs, case .compoundValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Aapt_Pb_Item {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Aapt_Pb_Item.OneOf_Value? = nil

  var ref: Aapt_Pb_Reference {
    get {
      if case .ref(let v)? = value {return v}
      return Aapt_Pb_Reference()
    }
    set {value = .ref(newValue)}
  }

  var str: Aapt_Pb_String {
    get {
      if case .str(let v)? = value {return v}
      return Aapt_Pb_String()
    }
    set {value = .str(newValue)}
  }

  var rawStr: Aapt_Pb_RawString {
    get {
      if case .rawStr(let v)? = value {return v}
      return Aapt_Pb_RawString()
    }
    set {value = .rawStr(newValue)}
  }

  var styledStr: Aapt_Pb_StyledString {
    get {
      if case .styledStr(let v)? = value {return v}
      return Aapt_Pb_StyledString()
    }
    set {value = .styledStr(newValue)}
  }

  var file: Aapt_Pb_FileReference {
    get {
      if case .file(let v)? = value {return v}
      return Aapt_Pb_FileReference()
    }
    set {value = .file(newValue)}
  }

  var id: Aapt_Pb_Id {
    get {
      if case .id(let v)? = value {return v}
      return Aapt_Pb_Id()
    }
    set {value = .id(newValue)}
  }

  var prim: Aapt_Pb_Primitive {
    get {
      if case .prim(let v)? = value {return v}
      return Aapt_Pb_Primitive()
    }
    set {value = .prim(newValue)}
  }

  var flagStatus: UInt32 = 0

  var flagNegated: Bool = false

  var flagName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case ref(Aapt_Pb_Reference)
    case str(Aapt_Pb_String)
    case rawStr(Aapt_Pb_RawString)
    case styledStr(Aapt_Pb_StyledString)
    case file(Aapt_Pb_FileReference)
    case id(Aapt_Pb_Id)
    case prim(Aapt_Pb_Primitive)

  #if !swift(>=4.1)
    static func ==(lhs: Aapt_Pb_Item.OneOf_Value, rhs: Aapt_Pb_Item.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ref, .ref): return {
        guard case .ref(let l) = lhs, case .ref(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.str, .str): return {
        guard case .str(let l) = lhs, case .str(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rawStr, .rawStr): return {
        guard case .rawStr(let l) = lhs, case .rawStr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.styledStr, .styledStr): return {
        guard case .styledStr(let l) = lhs, case .styledStr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.id, .id): return {
        guard case .id(let l) = lhs, case .id(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prim, .prim): return {
        guard case .prim(let l) = lhs, case .prim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Aapt_Pb_CompoundValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Aapt_Pb_CompoundValue.OneOf_Value? = nil

  var attr: Aapt_Pb_Attribute {
    get {
      if case .attr(let v)? = value {return v}
      return Aapt_Pb_Attribute()
    }
    set {value = .attr(newValue)}
  }

  var style: Aapt_Pb_Style {
    get {
      if case .style(let v)? = value {return v}
      return Aapt_Pb_Style()
    }
    set {value = .style(newValue)}
  }

  var styleable: Aapt_Pb_Styleable {
    get {
      if case .styleable(let v)? = value {return v}
      return Aapt_Pb_Styleable()
    }
    set {value = .styleable(newValue)}
  }

  var array: Aapt_Pb_Array {
    get {
      if case .array(let v)? = value {return v}
      return Aapt_Pb_Array()
    }
    set {value = .array(newValue)}
  }

  var plural: Aapt_Pb_Plural {
    get {
      if case .plural(let v)? = value {return v}
      return Aapt_Pb_Plural()
    }
    set {value = .plural(newValue)}
  }

  var macro: Aapt_Pb_MacroBody {
    get {
      if case .macro(let v)? = value {return v}
      return Aapt_Pb_MacroBody()
    }
    set {value = .macro(newValue)}
  }

  var flagStatus: UInt32 = 0

  var flagNegated: Bool = false

  var flagName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case attr(Aapt_Pb_Attribute)
    case style(Aapt_Pb_Style)
    case styleable(Aapt_Pb_Styleable)
    case array(Aapt_Pb_Array)
    case plural(Aapt_Pb_Plural)
    case macro(Aapt_Pb_MacroBody)

  #if !swift(>=4.1)
    static func ==(lhs: Aapt_Pb_CompoundValue.OneOf_Value, rhs: Aapt_Pb_CompoundValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.attr, .attr): return {
        guard case .attr(let l) = lhs, case .attr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.style, .style): return {
        guard case .style(let l) = lhs, case .style(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.styleable, .styleable): return {
        guard case .styleable(let l) = lhs, case .styleable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.plural, .plural): return {
        guard case .plural(let l) = lhs, case .plural(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.macro, .macro): return {
        guard case .macro(let l) = lhs, case .macro(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Aapt_Pb_Boolean {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_Reference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Aapt_Pb_Reference.TypeEnum = .reference

  var id: UInt32 = 0

  var name: String = String()

  var `private`: Bool = false

  var isDynamic: Aapt_Pb_Boolean {
    get {return _isDynamic ?? Aapt_Pb_Boolean()}
    set {_isDynamic = newValue}
  }
  /// Returns true if `isDynamic` has been explicitly set.
  var hasIsDynamic: Bool {return self._isDynamic != nil}
  /// Clears the value of `isDynamic`. Subsequent reads from it will return its default value.
  mutating func clearIsDynamic() {self._isDynamic = nil}

  var typeFlags: UInt32 = 0

  var allowRaw: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case reference // = 0
    case attribute // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .reference
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reference
      case 1: self = .attribute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reference: return 0
      case .attribute: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _isDynamic: Aapt_Pb_Boolean? = nil
}

#if swift(>=4.2)

extension Aapt_Pb_Reference.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_Reference.TypeEnum] = [
    .reference,
    .attribute,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_Id {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_String {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_RawString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_StyledString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var span: [Aapt_Pb_StyledString.Span] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Span {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tag: String = String()

    var firstChar: UInt32 = 0

    var lastChar: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Aapt_Pb_FileReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var type: Aapt_Pb_FileReference.TypeEnum = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case png // = 1
    case binaryXml // = 2
    case protoXml // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .png
      case 2: self = .binaryXml
      case 3: self = .protoXml
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .png: return 1
      case .binaryXml: return 2
      case .protoXml: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Aapt_Pb_FileReference.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_FileReference.TypeEnum] = [
    .unknown,
    .png,
    .binaryXml,
    .protoXml,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_Primitive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oneofValue: Aapt_Pb_Primitive.OneOf_OneofValue? = nil

  var nullValue: Aapt_Pb_Primitive.NullType {
    get {
      if case .nullValue(let v)? = oneofValue {return v}
      return Aapt_Pb_Primitive.NullType()
    }
    set {oneofValue = .nullValue(newValue)}
  }

  var emptyValue: Aapt_Pb_Primitive.EmptyType {
    get {
      if case .emptyValue(let v)? = oneofValue {return v}
      return Aapt_Pb_Primitive.EmptyType()
    }
    set {oneofValue = .emptyValue(newValue)}
  }

  var floatValue: Float {
    get {
      if case .floatValue(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .floatValue(newValue)}
  }

  var dimensionValue: UInt32 {
    get {
      if case .dimensionValue(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .dimensionValue(newValue)}
  }

  var fractionValue: UInt32 {
    get {
      if case .fractionValue(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .fractionValue(newValue)}
  }

  var intDecimalValue: Int32 {
    get {
      if case .intDecimalValue(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .intDecimalValue(newValue)}
  }

  var intHexadecimalValue: UInt32 {
    get {
      if case .intHexadecimalValue(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .intHexadecimalValue(newValue)}
  }

  var booleanValue: Bool {
    get {
      if case .booleanValue(let v)? = oneofValue {return v}
      return false
    }
    set {oneofValue = .booleanValue(newValue)}
  }

  var colorArgb8Value: UInt32 {
    get {
      if case .colorArgb8Value(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .colorArgb8Value(newValue)}
  }

  var colorRgb8Value: UInt32 {
    get {
      if case .colorRgb8Value(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .colorRgb8Value(newValue)}
  }

  var colorArgb4Value: UInt32 {
    get {
      if case .colorArgb4Value(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .colorArgb4Value(newValue)}
  }

  var colorRgb4Value: UInt32 {
    get {
      if case .colorRgb4Value(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .colorRgb4Value(newValue)}
  }

  var dimensionValueDeprecated: Float {
    get {
      if case .dimensionValueDeprecated(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .dimensionValueDeprecated(newValue)}
  }

  var fractionValueDeprecated: Float {
    get {
      if case .fractionValueDeprecated(let v)? = oneofValue {return v}
      return 0
    }
    set {oneofValue = .fractionValueDeprecated(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OneofValue: Equatable {
    case nullValue(Aapt_Pb_Primitive.NullType)
    case emptyValue(Aapt_Pb_Primitive.EmptyType)
    case floatValue(Float)
    case dimensionValue(UInt32)
    case fractionValue(UInt32)
    case intDecimalValue(Int32)
    case intHexadecimalValue(UInt32)
    case booleanValue(Bool)
    case colorArgb8Value(UInt32)
    case colorRgb8Value(UInt32)
    case colorArgb4Value(UInt32)
    case colorRgb4Value(UInt32)
    case dimensionValueDeprecated(Float)
    case fractionValueDeprecated(Float)

  #if !swift(>=4.1)
    static func ==(lhs: Aapt_Pb_Primitive.OneOf_OneofValue, rhs: Aapt_Pb_Primitive.OneOf_OneofValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nullValue, .nullValue): return {
        guard case .nullValue(let l) = lhs, case .nullValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.emptyValue, .emptyValue): return {
        guard case .emptyValue(let l) = lhs, case .emptyValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.floatValue, .floatValue): return {
        guard case .floatValue(let l) = lhs, case .floatValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dimensionValue, .dimensionValue): return {
        guard case .dimensionValue(let l) = lhs, case .dimensionValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fractionValue, .fractionValue): return {
        guard case .fractionValue(let l) = lhs, case .fractionValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intDecimalValue, .intDecimalValue): return {
        guard case .intDecimalValue(let l) = lhs, case .intDecimalValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intHexadecimalValue, .intHexadecimalValue): return {
        guard case .intHexadecimalValue(let l) = lhs, case .intHexadecimalValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanValue, .booleanValue): return {
        guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorArgb8Value, .colorArgb8Value): return {
        guard case .colorArgb8Value(let l) = lhs, case .colorArgb8Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorRgb8Value, .colorRgb8Value): return {
        guard case .colorRgb8Value(let l) = lhs, case .colorRgb8Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorArgb4Value, .colorArgb4Value): return {
        guard case .colorArgb4Value(let l) = lhs, case .colorArgb4Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorRgb4Value, .colorRgb4Value): return {
        guard case .colorRgb4Value(let l) = lhs, case .colorRgb4Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dimensionValueDeprecated, .dimensionValueDeprecated): return {
        guard case .dimensionValueDeprecated(let l) = lhs, case .dimensionValueDeprecated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fractionValueDeprecated, .fractionValueDeprecated): return {
        guard case .fractionValueDeprecated(let l) = lhs, case .fractionValueDeprecated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct NullType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EmptyType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Aapt_Pb_Attribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formatFlags: UInt32 = 0

  var minInt: Int32 = 0

  var maxInt: Int32 = 0

  var symbol: [Aapt_Pb_Attribute.Symbol] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FormatFlags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case any // = 65535
    case reference // = 1
    case string // = 2
    case integer // = 4
    case boolean // = 8
    case color // = 16
    case float // = 32
    case dimension // = 64
    case fraction // = 128
    case `enum` // = 65536
    case flags // = 131072
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .reference
      case 2: self = .string
      case 4: self = .integer
      case 8: self = .boolean
      case 16: self = .color
      case 32: self = .float
      case 64: self = .dimension
      case 128: self = .fraction
      case 65535: self = .any
      case 65536: self = .enum
      case 131072: self = .flags
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .reference: return 1
      case .string: return 2
      case .integer: return 4
      case .boolean: return 8
      case .color: return 16
      case .float: return 32
      case .dimension: return 64
      case .fraction: return 128
      case .any: return 65535
      case .enum: return 65536
      case .flags: return 131072
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Symbol {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Aapt_Pb_Source {
      get {return _source ?? Aapt_Pb_Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var comment: String = String()

    var name: Aapt_Pb_Reference {
      get {return _name ?? Aapt_Pb_Reference()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var value: UInt32 = 0

    var type: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: Aapt_Pb_Source? = nil
    fileprivate var _name: Aapt_Pb_Reference? = nil
  }

  init() {}
}

#if swift(>=4.2)

extension Aapt_Pb_Attribute.FormatFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_Attribute.FormatFlags] = [
    .none,
    .any,
    .reference,
    .string,
    .integer,
    .boolean,
    .color,
    .float,
    .dimension,
    .fraction,
    .enum,
    .flags,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_Style {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parent: Aapt_Pb_Reference {
    get {return _parent ?? Aapt_Pb_Reference()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var parentSource: Aapt_Pb_Source {
    get {return _parentSource ?? Aapt_Pb_Source()}
    set {_parentSource = newValue}
  }
  /// Returns true if `parentSource` has been explicitly set.
  var hasParentSource: Bool {return self._parentSource != nil}
  /// Clears the value of `parentSource`. Subsequent reads from it will return its default value.
  mutating func clearParentSource() {self._parentSource = nil}

  var entry: [Aapt_Pb_Style.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Aapt_Pb_Source {
      get {return _storage._source ?? Aapt_Pb_Source()}
      set {_uniqueStorage()._source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return _storage._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {_uniqueStorage()._source = nil}

    var comment: String {
      get {return _storage._comment}
      set {_uniqueStorage()._comment = newValue}
    }

    var key: Aapt_Pb_Reference {
      get {return _storage._key ?? Aapt_Pb_Reference()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {_uniqueStorage()._key = nil}

    var item: Aapt_Pb_Item {
      get {return _storage._item ?? Aapt_Pb_Item()}
      set {_uniqueStorage()._item = newValue}
    }
    /// Returns true if `item` has been explicitly set.
    var hasItem: Bool {return _storage._item != nil}
    /// Clears the value of `item`. Subsequent reads from it will return its default value.
    mutating func clearItem() {_uniqueStorage()._item = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _parent: Aapt_Pb_Reference? = nil
  fileprivate var _parentSource: Aapt_Pb_Source? = nil
}

struct Aapt_Pb_Styleable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: [Aapt_Pb_Styleable.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Aapt_Pb_Source {
      get {return _source ?? Aapt_Pb_Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var comment: String = String()

    var attr: Aapt_Pb_Reference {
      get {return _attr ?? Aapt_Pb_Reference()}
      set {_attr = newValue}
    }
    /// Returns true if `attr` has been explicitly set.
    var hasAttr: Bool {return self._attr != nil}
    /// Clears the value of `attr`. Subsequent reads from it will return its default value.
    mutating func clearAttr() {self._attr = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: Aapt_Pb_Source? = nil
    fileprivate var _attr: Aapt_Pb_Reference? = nil
  }

  init() {}
}

struct Aapt_Pb_Array {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var element: [Aapt_Pb_Array.Element] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Element {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Aapt_Pb_Source {
      get {return _source ?? Aapt_Pb_Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var comment: String = String()

    var item: Aapt_Pb_Item {
      get {return _item ?? Aapt_Pb_Item()}
      set {_item = newValue}
    }
    /// Returns true if `item` has been explicitly set.
    var hasItem: Bool {return self._item != nil}
    /// Clears the value of `item`. Subsequent reads from it will return its default value.
    mutating func clearItem() {self._item = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: Aapt_Pb_Source? = nil
    fileprivate var _item: Aapt_Pb_Item? = nil
  }

  init() {}
}

struct Aapt_Pb_Plural {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: [Aapt_Pb_Plural.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Arity: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case zero // = 0
    case one // = 1
    case two // = 2
    case few // = 3
    case many // = 4
    case other // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .zero
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .zero
      case 1: self = .one
      case 2: self = .two
      case 3: self = .few
      case 4: self = .many
      case 5: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .zero: return 0
      case .one: return 1
      case .two: return 2
      case .few: return 3
      case .many: return 4
      case .other: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: Aapt_Pb_Source {
      get {return _source ?? Aapt_Pb_Source()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var comment: String = String()

    var arity: Aapt_Pb_Plural.Arity = .zero

    var item: Aapt_Pb_Item {
      get {return _item ?? Aapt_Pb_Item()}
      set {_item = newValue}
    }
    /// Returns true if `item` has been explicitly set.
    var hasItem: Bool {return self._item != nil}
    /// Clears the value of `item`. Subsequent reads from it will return its default value.
    mutating func clearItem() {self._item = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: Aapt_Pb_Source? = nil
    fileprivate var _item: Aapt_Pb_Item? = nil
  }

  init() {}
}

#if swift(>=4.2)

extension Aapt_Pb_Plural.Arity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Aapt_Pb_Plural.Arity] = [
    .zero,
    .one,
    .two,
    .few,
    .many,
    .other,
  ]
}

#endif  // swift(>=4.2)

struct Aapt_Pb_XmlNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var node: Aapt_Pb_XmlNode.OneOf_Node? = nil

  var element: Aapt_Pb_XmlElement {
    get {
      if case .element(let v)? = node {return v}
      return Aapt_Pb_XmlElement()
    }
    set {node = .element(newValue)}
  }

  var text: String {
    get {
      if case .text(let v)? = node {return v}
      return String()
    }
    set {node = .text(newValue)}
  }

  var source: Aapt_Pb_SourcePosition {
    get {return _source ?? Aapt_Pb_SourcePosition()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Node: Equatable {
    case element(Aapt_Pb_XmlElement)
    case text(String)

  #if !swift(>=4.1)
    static func ==(lhs: Aapt_Pb_XmlNode.OneOf_Node, rhs: Aapt_Pb_XmlNode.OneOf_Node) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.element, .element): return {
        guard case .element(let l) = lhs, case .element(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _source: Aapt_Pb_SourcePosition? = nil
}

struct Aapt_Pb_XmlElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var namespaceDeclaration: [Aapt_Pb_XmlNamespace] = []

  var namespaceUri: String = String()

  var name: String = String()

  var attribute: [Aapt_Pb_XmlAttribute] = []

  var child: [Aapt_Pb_XmlNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_XmlNamespace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prefix: String = String()

  var uri: String = String()

  var source: Aapt_Pb_SourcePosition {
    get {return _source ?? Aapt_Pb_SourcePosition()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Aapt_Pb_SourcePosition? = nil
}

struct Aapt_Pb_XmlAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var namespaceUri: String = String()

  var name: String = String()

  var value: String = String()

  var source: Aapt_Pb_SourcePosition {
    get {return _source ?? Aapt_Pb_SourcePosition()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var resourceID: UInt32 = 0

  var compiledItem: Aapt_Pb_Item {
    get {return _compiledItem ?? Aapt_Pb_Item()}
    set {_compiledItem = newValue}
  }
  /// Returns true if `compiledItem` has been explicitly set.
  var hasCompiledItem: Bool {return self._compiledItem != nil}
  /// Clears the value of `compiledItem`. Subsequent reads from it will return its default value.
  mutating func clearCompiledItem() {self._compiledItem = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Aapt_Pb_SourcePosition? = nil
  fileprivate var _compiledItem: Aapt_Pb_Item? = nil
}

struct Aapt_Pb_MacroBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawString: String = String()

  var styleString: Aapt_Pb_StyledString {
    get {return _styleString ?? Aapt_Pb_StyledString()}
    set {_styleString = newValue}
  }
  /// Returns true if `styleString` has been explicitly set.
  var hasStyleString: Bool {return self._styleString != nil}
  /// Clears the value of `styleString`. Subsequent reads from it will return its default value.
  mutating func clearStyleString() {self._styleString = nil}

  var untranslatableSections: [Aapt_Pb_UntranslatableSection] = []

  var namespaceStack: [Aapt_Pb_NamespaceAlias] = []

  var source: Aapt_Pb_SourcePosition {
    get {return _source ?? Aapt_Pb_SourcePosition()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _styleString: Aapt_Pb_StyledString? = nil
  fileprivate var _source: Aapt_Pb_SourcePosition? = nil
}

struct Aapt_Pb_NamespaceAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prefix: String = String()

  var packageName: String = String()

  var isPrivate: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aapt_Pb_StyleString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var str: String = String()

  var spans: [Aapt_Pb_StyleString.Span] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Span {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var startIndex: UInt32 = 0

    var endIndex: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Aapt_Pb_UntranslatableSection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startIndex: UInt64 = 0

  var endIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "aapt.pb"

extension Aapt_Pb_StringPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StringPool, rhs: Aapt_Pb_StringPool) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_SourcePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourcePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "line_number"),
    2: .standard(proto: "column_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lineNumber) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.columnNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lineNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.lineNumber, fieldNumber: 1)
    }
    if self.columnNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.columnNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_SourcePosition, rhs: Aapt_Pb_SourcePosition) -> Bool {
    if lhs.lineNumber != rhs.lineNumber {return false}
    if lhs.columnNumber != rhs.columnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_idx"),
    2: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.pathIdx) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathIdx != 0 {
      try visitor.visitSingularUInt32Field(value: self.pathIdx, fieldNumber: 1)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Source, rhs: Aapt_Pb_Source) -> Bool {
    if lhs.pathIdx != rhs.pathIdx {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_ToolFingerprint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToolFingerprint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tool"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tool) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tool.isEmpty {
      try visitor.visitSingularStringField(value: self.tool, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_ToolFingerprint, rhs: Aapt_Pb_ToolFingerprint) -> Bool {
    if lhs.tool != rhs.tool {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_DynamicRefTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicRefTable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_id"),
    2: .standard(proto: "package_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._packageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._packageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_DynamicRefTable, rhs: Aapt_Pb_DynamicRefTable) -> Bool {
    if lhs._packageID != rhs._packageID {return false}
    if lhs.packageName != rhs.packageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_ResourceTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceTable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_pool"),
    2: .same(proto: "package"),
    3: .same(proto: "overlayable"),
    4: .standard(proto: "tool_fingerprint"),
    5: .standard(proto: "dynamic_ref_table"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sourcePool) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.package) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.overlayable) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.toolFingerprint) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.dynamicRefTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sourcePool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.package.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.package, fieldNumber: 2)
    }
    if !self.overlayable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.overlayable, fieldNumber: 3)
    }
    if !self.toolFingerprint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolFingerprint, fieldNumber: 4)
    }
    if !self.dynamicRefTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dynamicRefTable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_ResourceTable, rhs: Aapt_Pb_ResourceTable) -> Bool {
    if lhs._sourcePool != rhs._sourcePool {return false}
    if lhs.package != rhs.package {return false}
    if lhs.overlayable != rhs.overlayable {return false}
    if lhs.toolFingerprint != rhs.toolFingerprint {return false}
    if lhs.dynamicRefTable != rhs.dynamicRefTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_PackageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PackageId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_PackageId, rhs: Aapt_Pb_PackageId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Package: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Package"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_id"),
    2: .standard(proto: "package_name"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._packageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._packageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Package, rhs: Aapt_Pb_Package) -> Bool {
    if lhs._packageID != rhs._packageID {return false}
    if lhs.packageName != rhs.packageName {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_TypeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_TypeId, rhs: Aapt_Pb_TypeId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Type: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Type"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_id"),
    2: .same(proto: "name"),
    3: .same(proto: "entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._typeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._typeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Type, rhs: Aapt_Pb_Type) -> Bool {
    if lhs._typeID != rhs._typeID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.entry != rhs.entry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Visibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Visibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "source"),
    3: .same(proto: "comment"),
    4: .standard(proto: "staged_api"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.stagedApi) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .unknown {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 3)
    }
    if self.stagedApi != false {
      try visitor.visitSingularBoolField(value: self.stagedApi, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Visibility, rhs: Aapt_Pb_Visibility) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.stagedApi != rhs.stagedApi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Visibility.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PRIVATE"),
    2: .same(proto: "PUBLIC"),
  ]
}

extension Aapt_Pb_AllowNew: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowNew"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_AllowNew, rhs: Aapt_Pb_AllowNew) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Overlayable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Overlayable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "source"),
    3: .same(proto: "actor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.actor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.actor.isEmpty {
      try visitor.visitSingularStringField(value: self.actor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Overlayable, rhs: Aapt_Pb_Overlayable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._source != rhs._source {return false}
    if lhs.actor != rhs.actor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_OverlayableItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OverlayableItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "policy"),
    4: .standard(proto: "overlayable_idx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.policy) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.overlayableIdx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if !self.policy.isEmpty {
      try visitor.visitPackedEnumField(value: self.policy, fieldNumber: 3)
    }
    if self.overlayableIdx != 0 {
      try visitor.visitSingularUInt32Field(value: self.overlayableIdx, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_OverlayableItem, rhs: Aapt_Pb_OverlayableItem) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.policy != rhs.policy {return false}
    if lhs.overlayableIdx != rhs.overlayableIdx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_OverlayableItem.Policy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "PUBLIC"),
    2: .same(proto: "SYSTEM"),
    3: .same(proto: "VENDOR"),
    4: .same(proto: "PRODUCT"),
    5: .same(proto: "SIGNATURE"),
    6: .same(proto: "ODM"),
    7: .same(proto: "OEM"),
    8: .same(proto: "ACTOR"),
    9: .same(proto: "CONFIG_SIGNATURE"),
  ]
}

extension Aapt_Pb_StagedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StagedId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "staged_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stagedID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.stagedID != 0 {
      try visitor.visitSingularUInt32Field(value: self.stagedID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StagedId, rhs: Aapt_Pb_StagedId) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.stagedID != rhs.stagedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_EntryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_EntryId, rhs: Aapt_Pb_EntryId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_id"),
    2: .same(proto: "name"),
    3: .same(proto: "visibility"),
    4: .standard(proto: "allow_new"),
    5: .standard(proto: "overlayable_item"),
    6: .standard(proto: "config_value"),
    7: .standard(proto: "staged_id"),
    8: .standard(proto: "flag_disabled_config_value"),
  ]

  fileprivate class _StorageClass {
    var _entryID: Aapt_Pb_EntryId? = nil
    var _name: String = String()
    var _visibility: Aapt_Pb_Visibility? = nil
    var _allowNew: Aapt_Pb_AllowNew? = nil
    var _overlayableItem: Aapt_Pb_OverlayableItem? = nil
    var _configValue: [Aapt_Pb_ConfigValue] = []
    var _stagedID: Aapt_Pb_StagedId? = nil
    var _flagDisabledConfigValue: [Aapt_Pb_ConfigValue] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entryID = source._entryID
      _name = source._name
      _visibility = source._visibility
      _allowNew = source._allowNew
      _overlayableItem = source._overlayableItem
      _configValue = source._configValue
      _stagedID = source._stagedID
      _flagDisabledConfigValue = source._flagDisabledConfigValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._entryID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._visibility) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._allowNew) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._overlayableItem) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._configValue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._stagedID) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._flagDisabledConfigValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entryID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._allowNew {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._overlayableItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._configValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._configValue, fieldNumber: 6)
      }
      if let v = _storage._stagedID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._flagDisabledConfigValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._flagDisabledConfigValue, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Entry, rhs: Aapt_Pb_Entry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entryID != rhs_storage._entryID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._allowNew != rhs_storage._allowNew {return false}
        if _storage._overlayableItem != rhs_storage._overlayableItem {return false}
        if _storage._configValue != rhs_storage._configValue {return false}
        if _storage._stagedID != rhs_storage._stagedID {return false}
        if _storage._flagDisabledConfigValue != rhs_storage._flagDisabledConfigValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_ConfigValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_ConfigValue, rhs: Aapt_Pb_ConfigValue) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "weak"),
    4: .same(proto: "item"),
    5: .standard(proto: "compound_value"),
  ]

  fileprivate class _StorageClass {
    var _source: Aapt_Pb_Source? = nil
    var _comment: String = String()
    var _weak: Bool = false
    var _value: Aapt_Pb_Value.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _comment = source._comment
      _weak = source._weak
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._comment) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._weak) }()
        case 4: try {
          var v: Aapt_Pb_Item?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .item(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .item(v)}
        }()
        case 5: try {
          var v: Aapt_Pb_CompoundValue?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .compoundValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .compoundValue(v)}
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._comment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comment, fieldNumber: 2)
      }
      if _storage._weak != false {
        try visitor.visitSingularBoolField(value: _storage._weak, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._value {
      case .item?: try {
        guard case .item(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .compoundValue?: try {
        guard case .compoundValue(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Value, rhs: Aapt_Pb_Value) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._weak != rhs_storage._weak {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Item"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ref"),
    2: .same(proto: "str"),
    3: .standard(proto: "raw_str"),
    4: .standard(proto: "styled_str"),
    5: .same(proto: "file"),
    6: .same(proto: "id"),
    7: .same(proto: "prim"),
    8: .standard(proto: "flag_status"),
    9: .standard(proto: "flag_negated"),
    10: .standard(proto: "flag_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Aapt_Pb_Reference?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .ref(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .ref(v)}
      }()
      case 2: try {
        var v: Aapt_Pb_String?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .str(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .str(v)}
      }()
      case 3: try {
        var v: Aapt_Pb_RawString?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .rawStr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .rawStr(v)}
      }()
      case 4: try {
        var v: Aapt_Pb_StyledString?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .styledStr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .styledStr(v)}
      }()
      case 5: try {
        var v: Aapt_Pb_FileReference?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .file(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .file(v)}
      }()
      case 6: try {
        var v: Aapt_Pb_Id?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .id(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .id(v)}
      }()
      case 7: try {
        var v: Aapt_Pb_Primitive?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .prim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .prim(v)}
      }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.flagStatus) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.flagNegated) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.flagName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .ref?: try {
      guard case .ref(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .str?: try {
      guard case .str(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rawStr?: try {
      guard case .rawStr(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .styledStr?: try {
      guard case .styledStr(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .file?: try {
      guard case .file(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .id?: try {
      guard case .id(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .prim?: try {
      guard case .prim(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if self.flagStatus != 0 {
      try visitor.visitSingularUInt32Field(value: self.flagStatus, fieldNumber: 8)
    }
    if self.flagNegated != false {
      try visitor.visitSingularBoolField(value: self.flagNegated, fieldNumber: 9)
    }
    if !self.flagName.isEmpty {
      try visitor.visitSingularStringField(value: self.flagName, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Item, rhs: Aapt_Pb_Item) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.flagStatus != rhs.flagStatus {return false}
    if lhs.flagNegated != rhs.flagNegated {return false}
    if lhs.flagName != rhs.flagName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_CompoundValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompoundValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attr"),
    2: .same(proto: "style"),
    3: .same(proto: "styleable"),
    4: .same(proto: "array"),
    5: .same(proto: "plural"),
    6: .same(proto: "macro"),
    7: .standard(proto: "flag_status"),
    8: .standard(proto: "flag_negated"),
    9: .standard(proto: "flag_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Aapt_Pb_Attribute?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .attr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .attr(v)}
      }()
      case 2: try {
        var v: Aapt_Pb_Style?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .style(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .style(v)}
      }()
      case 3: try {
        var v: Aapt_Pb_Styleable?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .styleable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .styleable(v)}
      }()
      case 4: try {
        var v: Aapt_Pb_Array?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .array(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .array(v)}
      }()
      case 5: try {
        var v: Aapt_Pb_Plural?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .plural(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .plural(v)}
      }()
      case 6: try {
        var v: Aapt_Pb_MacroBody?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .macro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .macro(v)}
      }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.flagStatus) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.flagNegated) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.flagName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .attr?: try {
      guard case .attr(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .style?: try {
      guard case .style(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .styleable?: try {
      guard case .styleable(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .array?: try {
      guard case .array(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .plural?: try {
      guard case .plural(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .macro?: try {
      guard case .macro(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.flagStatus != 0 {
      try visitor.visitSingularUInt32Field(value: self.flagStatus, fieldNumber: 7)
    }
    if self.flagNegated != false {
      try visitor.visitSingularBoolField(value: self.flagNegated, fieldNumber: 8)
    }
    if !self.flagName.isEmpty {
      try visitor.visitSingularStringField(value: self.flagName, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_CompoundValue, rhs: Aapt_Pb_CompoundValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.flagStatus != rhs.flagStatus {return false}
    if lhs.flagNegated != rhs.flagNegated {return false}
    if lhs.flagName != rhs.flagName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Boolean: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Boolean"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Boolean, rhs: Aapt_Pb_Boolean) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Reference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "private"),
    5: .standard(proto: "is_dynamic"),
    6: .standard(proto: "type_flags"),
    7: .standard(proto: "allow_raw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.`private`) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._isDynamic) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.typeFlags) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.allowRaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .reference {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 4)
    }
    if let v = self._isDynamic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.typeFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.typeFlags, fieldNumber: 6)
    }
    if self.allowRaw != false {
      try visitor.visitSingularBoolField(value: self.allowRaw, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Reference, rhs: Aapt_Pb_Reference) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.`private` != rhs.`private` {return false}
    if lhs._isDynamic != rhs._isDynamic {return false}
    if lhs.typeFlags != rhs.typeFlags {return false}
    if lhs.allowRaw != rhs.allowRaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Reference.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REFERENCE"),
    1: .same(proto: "ATTRIBUTE"),
  ]
}

extension Aapt_Pb_Id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Id"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Id, rhs: Aapt_Pb_Id) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_String: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".String"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_String, rhs: Aapt_Pb_String) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_RawString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_RawString, rhs: Aapt_Pb_RawString) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_StyledString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyledString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "span"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.span) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.span.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.span, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StyledString, rhs: Aapt_Pb_StyledString) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.span != rhs.span {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_StyledString.Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_StyledString.protoMessageName + ".Span"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .standard(proto: "first_char"),
    3: .standard(proto: "last_char"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.firstChar) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.lastChar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    if self.firstChar != 0 {
      try visitor.visitSingularUInt32Field(value: self.firstChar, fieldNumber: 2)
    }
    if self.lastChar != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StyledString.Span, rhs: Aapt_Pb_StyledString.Span) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.firstChar != rhs.firstChar {return false}
    if lhs.lastChar != rhs.lastChar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_FileReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_FileReference, rhs: Aapt_Pb_FileReference) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_FileReference.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PNG"),
    2: .same(proto: "BINARY_XML"),
    3: .same(proto: "PROTO_XML"),
  ]
}

extension Aapt_Pb_Primitive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Primitive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "null_value"),
    2: .standard(proto: "empty_value"),
    3: .standard(proto: "float_value"),
    13: .standard(proto: "dimension_value"),
    14: .standard(proto: "fraction_value"),
    6: .standard(proto: "int_decimal_value"),
    7: .standard(proto: "int_hexadecimal_value"),
    8: .standard(proto: "boolean_value"),
    9: .standard(proto: "color_argb8_value"),
    10: .standard(proto: "color_rgb8_value"),
    11: .standard(proto: "color_argb4_value"),
    12: .standard(proto: "color_rgb4_value"),
    4: .standard(proto: "dimension_value_deprecated"),
    5: .standard(proto: "fraction_value_deprecated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Aapt_Pb_Primitive.NullType?
        if let current = self.oneofValue {
          try decoder.handleConflictingOneOf()
          if case .nullValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneofValue = .nullValue(v)}
      }()
      case 2: try {
        var v: Aapt_Pb_Primitive.EmptyType?
        if let current = self.oneofValue {
          try decoder.handleConflictingOneOf()
          if case .emptyValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.oneofValue = .emptyValue(v)}
      }()
      case 3: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.oneofValue = .floatValue(v)}
      }()
      case 4: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.oneofValue = .dimensionValueDeprecated(v)}
      }()
      case 5: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.oneofValue = .fractionValueDeprecated(v)}
      }()
      case 6: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.oneofValue = .intDecimalValue(v)}
      }()
      case 7: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .intHexadecimalValue(v)}
      }()
      case 8: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.oneofValue = .booleanValue(v)}
      }()
      case 9: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .colorArgb8Value(v)}
      }()
      case 10: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .colorRgb8Value(v)}
      }()
      case 11: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .colorArgb4Value(v)}
      }()
      case 12: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .colorRgb4Value(v)}
      }()
      case 13: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .dimensionValue(v)}
      }()
      case 14: try {
        if self.oneofValue != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.oneofValue = .fractionValue(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneofValue {
    case .nullValue?: try {
      guard case .nullValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .emptyValue?: try {
      guard case .emptyValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .floatValue?: try {
      guard case .floatValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case .dimensionValueDeprecated?: try {
      guard case .dimensionValueDeprecated(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }()
    case .fractionValueDeprecated?: try {
      guard case .fractionValueDeprecated(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }()
    case .intDecimalValue?: try {
      guard case .intDecimalValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }()
    case .intHexadecimalValue?: try {
      guard case .intHexadecimalValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }()
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .colorArgb8Value?: try {
      guard case .colorArgb8Value(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }()
    case .colorRgb8Value?: try {
      guard case .colorRgb8Value(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }()
    case .colorArgb4Value?: try {
      guard case .colorArgb4Value(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }()
    case .colorRgb4Value?: try {
      guard case .colorRgb4Value(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    }()
    case .dimensionValue?: try {
      guard case .dimensionValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    }()
    case .fractionValue?: try {
      guard case .fractionValue(let v)? = self.oneofValue else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Primitive, rhs: Aapt_Pb_Primitive) -> Bool {
    if lhs.oneofValue != rhs.oneofValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Primitive.NullType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Primitive.protoMessageName + ".NullType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Primitive.NullType, rhs: Aapt_Pb_Primitive.NullType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Primitive.EmptyType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Primitive.protoMessageName + ".EmptyType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Primitive.EmptyType, rhs: Aapt_Pb_Primitive.EmptyType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Attribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "format_flags"),
    2: .standard(proto: "min_int"),
    3: .standard(proto: "max_int"),
    4: .same(proto: "symbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.formatFlags) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minInt) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxInt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.symbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.formatFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.formatFlags, fieldNumber: 1)
    }
    if self.minInt != 0 {
      try visitor.visitSingularInt32Field(value: self.minInt, fieldNumber: 2)
    }
    if self.maxInt != 0 {
      try visitor.visitSingularInt32Field(value: self.maxInt, fieldNumber: 3)
    }
    if !self.symbol.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symbol, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Attribute, rhs: Aapt_Pb_Attribute) -> Bool {
    if lhs.formatFlags != rhs.formatFlags {return false}
    if lhs.minInt != rhs.minInt {return false}
    if lhs.maxInt != rhs.maxInt {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Attribute.FormatFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "REFERENCE"),
    2: .same(proto: "STRING"),
    4: .same(proto: "INTEGER"),
    8: .same(proto: "BOOLEAN"),
    16: .same(proto: "COLOR"),
    32: .same(proto: "FLOAT"),
    64: .same(proto: "DIMENSION"),
    128: .same(proto: "FRACTION"),
    65535: .same(proto: "ANY"),
    65536: .same(proto: "ENUM"),
    131072: .same(proto: "FLAGS"),
  ]
}

extension Aapt_Pb_Attribute.Symbol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Attribute.protoMessageName + ".Symbol"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "name"),
    4: .same(proto: "value"),
    5: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 4)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Attribute.Symbol, rhs: Aapt_Pb_Attribute.Symbol) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._name != rhs._name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Style: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Style"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "parent_source"),
    3: .same(proto: "entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parentSource) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._parentSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Style, rhs: Aapt_Pb_Style) -> Bool {
    if lhs._parent != rhs._parent {return false}
    if lhs._parentSource != rhs._parentSource {return false}
    if lhs.entry != rhs.entry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Style.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Style.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "key"),
    4: .same(proto: "item"),
  ]

  fileprivate class _StorageClass {
    var _source: Aapt_Pb_Source? = nil
    var _comment: String = String()
    var _key: Aapt_Pb_Reference? = nil
    var _item: Aapt_Pb_Item? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _comment = source._comment
      _key = source._key
      _item = source._item
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._comment) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._comment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comment, fieldNumber: 2)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Style.Entry, rhs: Aapt_Pb_Style.Entry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._item != rhs_storage._item {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Styleable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Styleable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Styleable, rhs: Aapt_Pb_Styleable) -> Bool {
    if lhs.entry != rhs.entry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Styleable.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Styleable.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "attr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._attr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if let v = self._attr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Styleable.Entry, rhs: Aapt_Pb_Styleable.Entry) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._attr != rhs._attr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Array"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.element.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Array, rhs: Aapt_Pb_Array) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Array.Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Array.protoMessageName + ".Element"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Array.Element, rhs: Aapt_Pb_Array.Element) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Plural: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Plural"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Plural, rhs: Aapt_Pb_Plural) -> Bool {
    if lhs.entry != rhs.entry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_Plural.Arity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ZERO"),
    1: .same(proto: "ONE"),
    2: .same(proto: "TWO"),
    3: .same(proto: "FEW"),
    4: .same(proto: "MANY"),
    5: .same(proto: "OTHER"),
  ]
}

extension Aapt_Pb_Plural.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_Plural.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "comment"),
    3: .same(proto: "arity"),
    4: .same(proto: "item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.arity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if self.arity != .zero {
      try visitor.visitSingularEnumField(value: self.arity, fieldNumber: 3)
    }
    if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_Plural.Entry, rhs: Aapt_Pb_Plural.Entry) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.arity != rhs.arity {return false}
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_XmlNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XmlNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
    2: .same(proto: "text"),
    3: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Aapt_Pb_XmlElement?
        if let current = self.node {
          try decoder.handleConflictingOneOf()
          if case .element(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.node = .element(v)}
      }()
      case 2: try {
        if self.node != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.node = .text(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.node {
    case .element?: try {
      guard case .element(let v)? = self.node else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .text?: try {
      guard case .text(let v)? = self.node else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_XmlNode, rhs: Aapt_Pb_XmlNode) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_XmlElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XmlElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "namespace_declaration"),
    2: .standard(proto: "namespace_uri"),
    3: .same(proto: "name"),
    4: .same(proto: "attribute"),
    5: .same(proto: "child"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.namespaceDeclaration) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespaceUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.child) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaceDeclaration.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaceDeclaration, fieldNumber: 1)
    }
    if !self.namespaceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceUri, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 4)
    }
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_XmlElement, rhs: Aapt_Pb_XmlElement) -> Bool {
    if lhs.namespaceDeclaration != rhs.namespaceDeclaration {return false}
    if lhs.namespaceUri != rhs.namespaceUri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.child != rhs.child {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_XmlNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XmlNamespace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "uri"),
    3: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_XmlNamespace, rhs: Aapt_Pb_XmlNamespace) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_XmlAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XmlAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "namespace_uri"),
    2: .same(proto: "name"),
    3: .same(proto: "value"),
    4: .same(proto: "source"),
    5: .standard(proto: "resource_id"),
    6: .standard(proto: "compiled_item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespaceUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.resourceID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._compiledItem) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceUri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.resourceID != 0 {
      try visitor.visitSingularUInt32Field(value: self.resourceID, fieldNumber: 5)
    }
    if let v = self._compiledItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_XmlAttribute, rhs: Aapt_Pb_XmlAttribute) -> Bool {
    if lhs.namespaceUri != rhs.namespaceUri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs._source != rhs._source {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs._compiledItem != rhs._compiledItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_MacroBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacroBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_string"),
    2: .standard(proto: "style_string"),
    3: .standard(proto: "untranslatable_sections"),
    4: .standard(proto: "namespace_stack"),
    5: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rawString) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._styleString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.untranslatableSections) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.namespaceStack) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawString.isEmpty {
      try visitor.visitSingularStringField(value: self.rawString, fieldNumber: 1)
    }
    if let v = self._styleString {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.untranslatableSections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.untranslatableSections, fieldNumber: 3)
    }
    if !self.namespaceStack.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaceStack, fieldNumber: 4)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_MacroBody, rhs: Aapt_Pb_MacroBody) -> Bool {
    if lhs.rawString != rhs.rawString {return false}
    if lhs._styleString != rhs._styleString {return false}
    if lhs.untranslatableSections != rhs.untranslatableSections {return false}
    if lhs.namespaceStack != rhs.namespaceStack {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_NamespaceAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .standard(proto: "package_name"),
    3: .standard(proto: "is_private"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isPrivate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 1)
    }
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 2)
    }
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_NamespaceAlias, rhs: Aapt_Pb_NamespaceAlias) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.packageName != rhs.packageName {return false}
    if lhs.isPrivate != rhs.isPrivate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_StyleString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "str"),
    2: .same(proto: "spans"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.str) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.str.isEmpty {
      try visitor.visitSingularStringField(value: self.str, fieldNumber: 1)
    }
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StyleString, rhs: Aapt_Pb_StyleString) -> Bool {
    if lhs.str != rhs.str {return false}
    if lhs.spans != rhs.spans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_StyleString.Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Aapt_Pb_StyleString.protoMessageName + ".Span"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "start_index"),
    3: .standard(proto: "end_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.startIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.endIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.startIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.startIndex, fieldNumber: 2)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.endIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_StyleString.Span, rhs: Aapt_Pb_StyleString.Span) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aapt_Pb_UntranslatableSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UntranslatableSection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
    2: .standard(proto: "end_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.startIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.endIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.endIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.endIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aapt_Pb_UntranslatableSection, rhs: Aapt_Pb_UntranslatableSection) -> Bool {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
